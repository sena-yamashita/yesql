# ベンチマークヘルパー
# 各ドライバーのパフォーマンステストで使用する共通ユーティリティ

defmodule BenchHelper do
  @doc """
  ベンチマーク結果を整形して表示
  """
  def format_results(results) do
    IO.puts("\n=== ベンチマーク結果 ===")
    
    Enum.each(results, fn {name, time} ->
      avg_time = time / 1000.0  # マイクロ秒からミリ秒に変換
      ops_per_sec = 1_000_000.0 / time
      
      IO.puts("#{String.pad_trailing(to_string(name), 30)} #{:io_lib.format("~10.3f", [avg_time])} ms/op    #{:io_lib.format("~10.2f", [ops_per_sec])} ops/sec")
    end)
    
    IO.puts("")
  end
  
  @doc """
  タイマーを使用して関数の実行時間を測定
  """
  def measure(fun, iterations \\ 1000) do
    # ウォームアップ
    for _ <- 1..10, do: fun.()
    
    # 実測定
    {time, _} = :timer.tc(fn ->
      for _ <- 1..iterations, do: fun.()
    end)
    
    time / iterations  # 1回あたりの平均時間（マイクロ秒）
  end
  
  @doc """
  テスト用のSQLファイルを作成
  """
  def create_test_sql_files(dir) do
    File.mkdir_p!(dir)
    
    # シンプルなSELECTクエリ
    File.write!(Path.join(dir, "simple_select.sql"), """
    -- name: simple_select
    SELECT * FROM users WHERE id = :id;
    """)
    
    # 複数パラメータのクエリ
    File.write!(Path.join(dir, "multi_param_select.sql"), """
    -- name: multi_param_select
    SELECT * FROM users 
    WHERE age >= :min_age 
      AND age <= :max_age 
      AND status = :status
    ORDER BY created_at DESC;
    """)
    
    # JOINを含むクエリ
    File.write!(Path.join(dir, "complex_join.sql"), """
    -- name: complex_join
    SELECT u.*, p.title, p.content
    FROM users u
    JOIN posts p ON u.id = p.user_id
    WHERE u.status = :status
      AND p.created_at > :since
    ORDER BY p.created_at DESC;
    """)
    
    # INSERTクエリ
    File.write!(Path.join(dir, "insert_user.sql"), """
    -- name: insert_user
    INSERT INTO users (name, email, age, status)
    VALUES (:name, :email, :age, :status);
    """)
  end
  
  @doc """
  テスト用のテーブルを作成するSQL
  """
  def create_tables_sql(:postgresql) do
    """
    CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      email VARCHAR(255) UNIQUE,
      age INTEGER,
      status VARCHAR(50),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE TABLE IF NOT EXISTS posts (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(id),
      title VARCHAR(255),
      content TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    """
  end
  
  def create_tables_sql(:mysql) do
    """
    CREATE TABLE IF NOT EXISTS users (
      id INT AUTO_INCREMENT PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      email VARCHAR(255) UNIQUE,
      age INT,
      status VARCHAR(50),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE TABLE IF NOT EXISTS posts (
      id INT AUTO_INCREMENT PRIMARY KEY,
      user_id INT,
      title VARCHAR(255),
      content TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id)
    );
    """
  end
  
  def create_tables_sql(:mssql) do
    """
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='users' AND xtype='U')
    CREATE TABLE users (
      id INT IDENTITY(1,1) PRIMARY KEY,
      name NVARCHAR(255) NOT NULL,
      email NVARCHAR(255) UNIQUE,
      age INT,
      status NVARCHAR(50),
      created_at DATETIME2 DEFAULT GETDATE()
    );
    
    IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='posts' AND xtype='U')
    CREATE TABLE posts (
      id INT IDENTITY(1,1) PRIMARY KEY,
      user_id INT FOREIGN KEY REFERENCES users(id),
      title NVARCHAR(255),
      content NVARCHAR(MAX),
      created_at DATETIME2 DEFAULT GETDATE()
    );
    """
  end
  
  def create_tables_sql(:oracle) do
    """
    BEGIN
      EXECUTE IMMEDIATE 'CREATE TABLE users (
        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR2(255) NOT NULL,
        email VARCHAR2(255) UNIQUE,
        age NUMBER,
        status VARCHAR2(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )';
    EXCEPTION
      WHEN OTHERS THEN
        IF SQLCODE = -955 THEN NULL; ELSE RAISE; END IF;
    END;
    /
    
    BEGIN
      EXECUTE IMMEDIATE 'CREATE TABLE posts (
        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id NUMBER REFERENCES users(id),
        title VARCHAR2(255),
        content CLOB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )';
    EXCEPTION
      WHEN OTHERS THEN
        IF SQLCODE = -955 THEN NULL; ELSE RAISE; END IF;
    END;
    /
    """
  end
  
  def create_tables_sql(:duckdb) do
    """
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY,
      name VARCHAR NOT NULL,
      email VARCHAR UNIQUE,
      age INTEGER,
      status VARCHAR,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE SEQUENCE IF NOT EXISTS users_id_seq START 1;
    
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY,
      user_id INTEGER REFERENCES users(id),
      title VARCHAR,
      content TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE SEQUENCE IF NOT EXISTS posts_id_seq START 1;
    """
  end
  
  @doc """
  テストデータを挿入
  """
  def insert_test_data(conn, driver_type, count \\ 100) do
    users = for i <- 1..count do
      %{
        name: "User #{i}",
        email: "user#{i}@example.com",
        age: rem(i, 50) + 20,
        status: Enum.random(["active", "inactive", "pending"])
      }
    end
    
    # ドライバー固有の一括挿入処理
    case driver_type do
      :postgresql ->
        # Postgrexの場合
        users_sql = """
        INSERT INTO users (name, email, age, status)
        VALUES ($1, $2, $3, $4)
        """
        Enum.each(users, fn user ->
          Postgrex.query!(conn, users_sql, [user.name, user.email, user.age, user.status])
        end)
        
      :mysql ->
        # MySQLの場合
        users_sql = """
        INSERT INTO users (name, email, age, status)
        VALUES (?, ?, ?, ?)
        """
        Enum.each(users, fn user ->
          MyXQL.query!(conn, users_sql, [user.name, user.email, user.age, user.status])
        end)
        
      _ ->
        IO.puts("警告: #{driver_type}のテストデータ挿入は未実装です")
    end
  end
  
  @doc """
  クリーンアップ処理
  """
  def cleanup(conn, driver_type) do
    case driver_type do
      :postgresql ->
        Postgrex.query!(conn, "DROP TABLE IF EXISTS posts CASCADE", [])
        Postgrex.query!(conn, "DROP TABLE IF EXISTS users CASCADE", [])
        
      :mysql ->
        MyXQL.query!(conn, "DROP TABLE IF EXISTS posts", [])
        MyXQL.query!(conn, "DROP TABLE IF EXISTS users", [])
        
      _ ->
        IO.puts("警告: #{driver_type}のクリーンアップは未実装です")
    end
  end
end